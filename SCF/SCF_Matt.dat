#SCF Implementation with DIIS using Psi4 molecule, MintsHelper, and wfn.

import numpy
import time 
print "SCF Implementation with DIIS, DF, BlAS options\n"

molecule mol {
    O
    H 1 1.1
    H 1 1.1 2 104
    symmetry c1
}

start = time.time()

set {
    scf_type df
    df_basis_scf cc-pVDZ
    basis cc-pVDZ
}

Zconstruction = 0
conv_tol = 1e-10
DIIS, DIIS_size = False, 10
DF, BLAS = True, True


# Create wavefunction using basis set 6-31G.
wfn = psi4.new_wavefunction(mol,psi4.get_global_option('BASIS'))
#The MintsHelper object places molecular integrals (and later derivative integrals) on disk.
M = psi4.MintsHelper(wfn.basisset())
#Access orbital overlaps, store in matrix S.
S = np.asarray(M.ao_overlap())
#Access kinetic energies, store in matrix T
T = np.asarray(M.ao_kinetic())
#Access coloumbic energies, store in matrix V
V = np.asarray(M.ao_potential())
#Store Hamiltonian.
H = T + V


#A = S^(1/2)
eigval, eigvec = np.linalg.eigh(S)
eigval **= -0.5
A = np.dot(eigvec*eigval,eigvec.T)
ndocc = wfn.nalpha()


#Diagonalize F and Produce Density Matrix
Fp = np.dot(A.T,H).dot(A)
eigval, eigvec = np.linalg.eigh(Fp)
C = np.dot(A,eigvec)
Cocc = C[:,:ndocc]
D = np.dot(Cocc,Cocc.T)
c = np.shape(Cocc)


#Size check for two-electron integrals
orbs = S.shape[0]
#Gb of data for two-electron integrals
size = (orbs**4)*8/1.e9
if size > 14:
    raise Exception("G tensor is too big!")


#Build the density fitted version
scf_e, scf_wfn = energy('SCF', return_wfn=True)
dfobj = DFTensor(scf_wfn, "DF_BASIS_SCF")
Qpq = np.asarray(dfobj.Qso())
s = np.shape(Qpq)

#Build the 4D tensor if DF is not selected
if not DF:
    g = np.einsum('Qpq,Qrs->pqrs',Qpq,Qpq)


#Apply variational method which knows when to stop.
SCFE = 0
SCFE_old = 1
count = 0
ztime = 0

#Initiate set of trial vectors, error vectors.
trials = []
errors = []


itstart = time.time()
while SCFE_old - SCFE > conv_tol:
    
    if count > 99:
        raise Exception("Calculation Exceeds 100 Iterations!")

    #Construct Fock Matrix and append to trials
    
    if not DF:
        #O(n^5) in both cases
        J = np.einsum('pqrs,rs->pq',g,D)
        K = np.einsum('prqs,rs->pq',g,D)
    elif DF:
        if not BLAS:
            #J Construction O(N^3) using einsum
            tmp = np.einsum('Qrs,rs->Q',Qpq,D)
            J = np.einsum('Qpq,Q->pq',Qpq,tmp)
                        
            #K Construction: O(N^4) using einsum
            #tmp = np.einsum('Qqs,rs->Qqr',Qpq,D)
            #K = np.einsum('Qqr,Qrp->pq',tmp,Qpq)

            #K Construction: O(pN^2Naux) using orbital matrix and einsum
            Z1 = np.einsum('Qrs,sq->Qrq',Qpq,Cocc)
            K = np.einsum('Qpq,Qrq->pr',Z1,Z1)
            
        else:
            #BLAS
          
            #J Construction: O(N^3)
            tmp = np.dot(Qpq.reshape(s[0],s[1]*s[2]),D.reshape(s[1]*s[2]))
            J = np.dot(tmp,Qpq.reshape(s[0],s[1]*s[2])).reshape(s[1],s[2])

            #K Construction: O(N^4)
            #tmp = np.dot(Qpq.reshape(s[0]*s[1],s[2]),D.T).reshape(s)
            #tmp = np.einsum('Qqr->Qrq',tmp)
            #K = np.dot(Qpq.reshape(s[0]*s[1],s[2]).T,tmp.reshape(-1,s[2]))
             
            #K Construction: O(pN^2Naux) using orbital matrix
            if Zconstruction:    
                stime = time.time()
                Z1 = np.dot(Qpq.reshape(s[0]*s[1],s[2]),Cocc).reshape(s[0],s[1],-1)
                ztime += (time.time() - stime)   
                Z1 = np.einsum('Qpi -> Qip',Z1)
                K = np.dot(Z1.reshape(s[0]*c[1],s[1]).T,Z1.reshape(s[0]*c[1],s[1]))
            else:
                stime = time.time()
                Z_1 = np.dot(Cocc.T, Qpq.reshape(s[0] * s[1], s[1]).T)    
                ztime += (time.time() - stime)
                K = np.dot(Z_1.reshape(-1, s[1]).T, Z_1.reshape(-1, s[1])).reshape(s[1], s[1])
            
    
    F = H + 2*J - K 
    #Compute Energy
    Eelec = np.einsum('qr,qr->',F + H,D)
    Enuc = mol.nuclear_repulsion_energy()
    SCFE_old = SCFE
    SCFE = Eelec + Enuc
    print ("dE: %6.12f" % (SCFE_old - SCFE))
    
    if DIIS == 1:
        trials.append(F)

        #Obtain DIIS error
        r = np.dot(A.T,(np.dot(F,D).dot(S)-np.dot(S,D).dot(F))).dot(A)    
        if len(errors) > DIIS_size: #only keep the DIIS_size most recent guesses for use.
            del errors[0]
            del trials[0]
        errors.append(r)    
        
        #Build B
        size = len(errors)+1
        B = np.zeros((size,size))
        B[-1] = -1
        B[:,-1] = -1
        B[-1,-1] = 0
        for i in range(size-1):
            for j in range(size-1):
                B[i,j] = np.sum(errors[i]*errors[j])
    
        #Solve for Cn
        vec = np.zeros(size)
        vec[-1] = -1
        inverse = np.linalg.inv(B)
        Cn = np.linalg.solve(B,vec)
                
        #Rebuild Fock Matrix according to Cn
        F = np.zeros_like(H)
        for i in range(len(Cn)-1):
            F += Cn[i]*trials[i]
    
    #Diagonalize F and Reproduce Density Matrix
    Fp = np.dot(A.T,F).dot(A)
    eigval, eigvec = np.linalg.eigh(Fp)
    C = np.dot(A,eigvec)
    Cocc = C[:,:ndocc]
    D = np.einsum('pi,qi->pq',Cocc,Cocc)

    count += 1        

print ("Total time in iterations: %6.3f" % (time.time() - itstart))
print ("\nDIIS: %s  \nDF: %s  \nBLAS: %s " % (DIIS ,DF ,BLAS))
print ("Number of iterations: %d" % count)
if BLAS:
    print ("Total time building Zeta: %6.6f\n" % ztime)    
print ("SCF Energy: %12.10f" % SCFE)
print ("Runtime:      %6.6f\n" % (time.time() - start))
start = time.time()
print ("Energy from Psi4: % 12.10f" % energy('SCF'))
print ("Psi4 runtime: %6.6f" % (time.time() - start))
